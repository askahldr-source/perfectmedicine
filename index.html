<script>
/*
Integrated option-chain + live updater script.
Behavior:
- Tries to fetch JSON from repo: /data/<TICKER>_all.json (raw.githubusercontent)
- If not found, uses local sample data to render table & chart
- You can paste this full index.html into your repo to replace existing page.
*/

/* ---------- CONFIG: set real endpoints here (optional) ---------- */
/* Example: SPOT_API_URL could be your server or a market-data endpoint that returns { price: 25709.85 } for a GET.
   Leave empty to use simulated spot updates. */
const SPOT_API_URL = ''; // e.g. 'https://your.api/spot?symbol=NIFTY'
const OPTIONS_API_BASE = ''; // e.g. 'https://your.api/options?ticker='  (if empty, repo/raw or sample used)
const STREAM_INTERVAL_MS = 10_000; // how often to poll live spot & options

/* ---------- sample fallback data (keeps UI working if JSON missing) ---------- */
const sampleRows = (() => {
  const strikes = [25450,25500,25550,25600,25650,25700,25750,25800,25850,25900,25950,26000];
  const rows = [];
  for (let i=0;i<strikes.length;i++){
    const k=strikes[i];
    rows.push({
      expiry: '2025-10-30',
      type: i<6 ? 'put' : 'call',
      strike: k,
      bid: (Math.random()*60).toFixed(2),
      ask: (Math.random()*80+20).toFixed(2),
      mid: (Math.random()*70+10).toFixed(2),
      impliedVol: (Math.random()*0.45+0.12).toFixed(4),
      vol_used: (Math.random()*0.45+0.12).toFixed(4),
      days: 12,
      delta: (Math.random()*2-1).toFixed(4),
      gamma: (Math.random()*0.05).toFixed(5),
      vega: (Math.random()*10).toFixed(3),
      theta: (-Math.random()*5).toFixed(3),
      openInterest: Math.floor(Math.random()*900000),
      volume: Math.floor(Math.random()*200000),
      oiChange: (Math.random()*10000-5000).toFixed(0),
      contract: 'OPT' + k
    });
  }
  return rows;
})();

/* ---------- rendering functions ---------- */
function renderOptionTable(rows, spot){
  const tbody = document.getElementById('optBody');
  tbody.innerHTML = '';
  if (!rows || rows.length===0){
    tbody.innerHTML = '<tr><td colspan="9" class="leftCol">No option data</td></tr>';
    return;
  }

  rows.sort((a,b)=>Number(a.strike) - Number(b.strike));

  // determine index of nearest strike to spot
  let atmIndex = null;
  if (typeof spot === 'number' && !Number.isNaN(spot)){
    let bestDiff = Infinity;
    for (let i=0;i<rows.length;i++){
      const s = Number(rows[i].strike);
      const d = Math.abs(s - spot);
      if (d < bestDiff){ bestDiff = d; atmIndex = i; }
    }
  } else {
    atmIndex = Math.floor(rows.length/2);
  }

  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const tr = document.createElement('tr');

    const leftHtml = `<td>${r.oiChange}</td><td>${Number(r.openInterest).toLocaleString()}</td><td>${Number(r.volume).toLocaleString()}</td><td class="leftCol">${r.type==='call' ? '' : 'Break Out'}</td>`;
    const strikeNum = Number(r.strike);
    const strikeCellClass = 'strike-cell' + (i === atmIndex ? ' atm' : '');
    const strikeCell = `<td class="${strikeCellClass} leftCol">${isFinite(strikeNum) ? strikeNum.toFixed(0) : r.strike}</td>`;
    const rightHtml = `<td class="leftCol">${r.type==='call' ? 'Break Down' : ''}</td><td>${Number(r.volume).toLocaleString()}</td><td>${Number(r.openInterest).toLocaleString()}</td><td>${r.oiChange}</td>`;

    tr.innerHTML = leftHtml + strikeCell + rightHtml;

    if (i === atmIndex){
      tr.classList.add('atm-row');
    }

    tbody.appendChild(tr);
  }
}

/* ---------- chart (line) ---------- */
let priceChart = null;
function initChart(){
  const ctx = document.getElementById('priceChart').getContext('2d');
  priceChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'Price',
        data: [],
        borderColor: '#2b8cff',
        backgroundColor: 'rgba(43,140,255,0.06)',
        tension: 0.15,
        pointRadius: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      plugins: { legend: { display: false } },
      scales: {
        x: { display: true, grid: { color: '#f3f6f8' } },
        y: { display: true, grid: { color: '#f3f6f8' } }
      }
    }
  });
}

function appendPricePoint(price){
  if (!priceChart) return;
  const labels = priceChart.data.labels;
  const data = priceChart.data.datasets[0].data;
  const ts = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
  labels.push(ts);
  data.push(Number(price));
  // keep last 60 points
  if (labels.length > 60) { labels.shift(); data.shift(); }
  priceChart.update('none');
}

/* ---------- fetch repo JSON if available (raw.githubusercontent) ---------- */
async function fetchRepoJson(ticker='AAPL'){
  // prefer OPTIONS_API_BASE if provided
  if (OPTIONS_API_BASE){
    try {
      const resp = await fetch(`${OPTIONS_API_BASE}${encodeURIComponent(ticker)}`, {cache:'no-store'});
      if (resp.ok) return await resp.json();
    } catch {}
  }

  const url = `https://raw.githubusercontent.com/askahldr-source/perfectmedicine/main/data/${ticker}_all.json`;
  try {
    const resp = await fetch(url, {cache:'no-store'});
    if (!resp.ok) throw new Error('No repo json');
    const j = await resp.json();
    return j.rows || j.data || j;
  } catch (err){
    console.warn('repo json not available:', err);
    return null;
  }
}

/* ---------- fetch spot price (real or simulated) ---------- */
let _simSpot = 25709.85;
async function fetchSpotPrice(ticker='NIFTY'){
  // real endpoint if configured
  if (SPOT_API_URL){
    try {
      const url = typeof SPOT_API_URL === 'function' ? SPOT_API_URL(ticker) : `${SPOT_API_URL}${encodeURIComponent(ticker)}`;
      const resp = await fetch(url, {cache:'no-store'});
      if (!resp.ok) throw new Error('spot fetch failed');
      const j = await resp.json();
      // expect { price: number } or path to price
      const p = j.price ?? j.last ?? j.priceUsd ?? j.quote?.price ?? j[0]?.price;
      if (typeof p === 'number') return p;
    } catch (err){
      console.warn('spot fetch failed', err);
    }
  }

  // fallback: simulated random walk based on previous value
  _simSpot += (Math.random()-0.5) * 20; // adjust volatility
  return Number(_simSpot.toFixed(2));
}

/* ---------- orchestrator: load & render ---------- */
let autoTimer = null;
async function loadAndRender(){
  const ticker = (document.getElementById('tickerSelect').value||'NIFTY');
  // parallel fetch spot & options
  const [spot, repoRows] = await Promise.all([fetchSpotPrice(ticker), fetchRepoJson(ticker).catch(()=>null)]);
  // display spot
  const spotEl = document.getElementById('spotVal');
  if (spotEl && typeof spot === 'number') spotEl.textContent = spot.toFixed(2);

  const rows = (repoRows && Array.isArray(repoRows) && repoRows.length>0) ? repoRows : sampleRows;
  renderOptionTable(rows, spot);
  appendPricePoint(spot);
  document.getElementById('refreshBtn').textContent = 'Refresh';
}

/* ---------- controls ---------- */
document.getElementById('refreshBtn').addEventListener('click', async function(){
  this.textContent = 'Loading...';
  await loadAndRender();
});

document.getElementById('startBtn').addEventListener('click', function(){
  if (autoTimer){
    clearInterval(autoTimer);
    autoTimer = null;
    this.textContent = 'Auto';
    setStatus('Auto stopped');
  } else {
    // first immediate run then interval
    loadAndRender();
    autoTimer = setInterval(loadAndRender, STREAM_INTERVAL_MS);
    this.textContent = 'Stop Auto';
    setStatus('Auto updating every ' + (STREAM_INTERVAL_MS/1000) + 's');
  }
});

/* ---------- status helper ---------- */
function setStatus(txt){
  const el = document.getElementById('marketStatus');
  if (el) el.textContent = txt;
}

/* ---------- init ---------- */
window.addEventListener('DOMContentLoaded', function(){
  initChart();
  loadAndRender();
});
</script>
